# ABC129

## A - Airplane
min(P+Q,min(Q+R,P+R)) = P+Q+R - max(P,max(Q,R))

## B - Balance
全探索すれば良いが、練習だと思って累積和で解いた。

## C - Typical Stairs
フィボナッチ数列型のDP、貰うならdp[i] = dp[i-1]+dp[i-2]、配るならdp[i+1] += dp[i], dp[i+2] += dp[i]  
いずれも、範囲外参照に注意。  
壊れた床については、他の配列で管理しておくと楽。  

## D - Lamp
### 考えたこと
- 障害物のあるグリッド上で十字の大きさを求める問題。二分探索でやったことある！  
- 横から見たときに各行にどのように障害物が出てくるか？各列についても同様に、その配列を作る。row[][]とcol[][]    
- グリッド上を全探索し、その位置から上下左右にあるもっとも近い障害物の位置を二分探索で求める。  
- (i,j) において、配列row[i]の中で、jより大きい座標の中で最小のもの、jより小さい座標の中で最大のものを求める。col[j]についても同様。  

### 解説
- 二分探索解は即座に思いつくが、実装が重くてミスしやすい、実装力を鍛えるのも大切だし、解説のように簡単にやることも大切。そんなに簡単でもないけど  

## E - Sum Equals Xor
### 考えたこと
- a + b = a xor b という条件は、aのXbit目をa(X)、bのそれをb(X)とすると、{a(X),b(X)} = {0,0},{1,0},{0,1} であることである。  
- 上の組み合わせを各桁に割り振っていく。  
- a + b <= L という条件は、桁DPでうまく処理できる。
- dp tableをdp[i][j] := 上からi桁目まで見たとき、既にa+b<=Lが確定している状態j=1とまだ確定していない状態j=0の場合の数の総数。  
- 遷移  
  - L[i]==1のとき、(i,0)*2 -> (i+1,0) , (i,0) -> (i+1,1) , (i,1)*3 -> (i+1,1)  
  - L[i]==0のとき、(i,0) -> (i+1,0) , (i,1)*3 -> (i+1,1)  
